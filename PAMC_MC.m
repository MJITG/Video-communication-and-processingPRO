function [intpldFrame,occ] = PAMC_MC(refFrame,curFrame,mv_fld_x,mv_fld_y)
%PAMC_MC 此处显示有关此函数的摘要
%   此处显示详细说明
[height,width]=size(refFrame);

y_ext=zeros(height+16*2,width+16*2,3);
y_ext(16+1:height+16,16+1:width+16,1)=curFrame; 
y_ext(16+1:height+16,16+1:width+16,3)=refFrame;

occ=zeros(height+16*2,width+16*2);%表示重叠次数，0次为hole，1表示已填充表示发生重叠，2表示发生重叠
SADfld=ones(height+16*2,width+16*2).*10000;%SAD场，每个像素点都有，用于PAMC判别

mv_height=height/8;
mv_width=width/8;
for i=1:mv_height
    for j=1:mv_width
        
        intpldFrameTemp=zeros(height+16*2,width+16*2);%临时补偿帧，意图为记录新进来的补偿块，以作比较
        SADfldTemp=zeros(height+16*2,width+16*2);%临时SADfld，意图为记录新进来的补偿块SAD
        intpldFrameTemp(16+1+(i-1)*8+round(mv_fld_y(i,j)/2):16+i*8+round(mv_fld_y(i,j)/2),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)/2):16+j*8+round(mv_fld_x(i,j)/2))=...
            (y_ext(16+1+(i-1)*8:16+i*8,16+1+(j-1)*8:16+j*8,1)+...
            y_ext(16+1+(i-1)*8+round(mv_fld_y(i,j)):16+i*8+round(mv_fld_y(i,j)),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)):16+j*8+round(mv_fld_x(i,j)),3))/2;
        SADfldTemp(16+1+(i-1)*8+round(mv_fld_y(i,j)/2):16+i*8+round(mv_fld_y(i,j)/2),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)/2):16+j*8+round(mv_fld_x(i,j)/2))=sum(sum(...
            (abs(y_ext(16+1+(i-1)*8:16+i*8,16+1+(j-1)*8:16+j*8,1)-...
            y_ext(16+1+(i-1)*8+round(mv_fld_y(i,j)):16+i*8+round(mv_fld_y(i,j)),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)):16+j*8+round(mv_fld_x(i,j)),3)))));
        %均值法补偿
        occ(16+1+(i-1)*8+round(mv_fld_y(i,j)/2):16+i*8+round(mv_fld_y(i,j)/2),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)/2):16+j*8+round(mv_fld_x(i,j)/2))=...
        occ(16+1+(i-1)*8+round(mv_fld_y(i,j)/2):16+i*8+round(mv_fld_y(i,j)/2),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)/2):16+j*8+round(mv_fld_x(i,j)/2))+1;  
        %像素被填充一次则加1  
        [r,c]=find(occ==2);%重叠区域occ为2
        for n=1:size(r)
            if(SADfld(r(n),c(n))<SADfldTemp(r(n),c(n))&&...
                    ~((r(n)>=16+1+(i-1)*8+round(mv_fld_y(i,j)/2)+2)&&(r(n)<16+1+(i-1)*8+round(mv_fld_y(i,j)/2)+6))&&...
                    ~((c(n)>=16+1+(j-1)*8+round(mv_fld_x(i,j)/2)+2)&&(c(n)<16+1+(j-1)*8+round(mv_fld_x(i,j)/2)+6)))
                %判断重叠区域是否在中心区域外
               intpldFrameTemp(r(n),c(n))=y_ext(r(n),c(n),2);%替换值
               SADfldTemp(r(n),c(n))=SADfld(r(n),c(n));%替换SADfld值
            else if(SADfld(r(n),c(n))>=SADfldTemp(r(n),c(n))&&...
                   ~((r(n)>=16+1+(i-1)*8+round(mv_fld_y(i,j)/2)+2)&&(r(n)<16+1+(i-1)*8+round(mv_fld_y(i,j)/2)+6))&&...
                   ~((c(n)>=16+1+(j-1)*8+round(mv_fld_x(i,j)/2)+2)&&(c(n)<16+1+(j-1)*8+round(mv_fld_x(i,j)/2)+6)))
                intpldFrameTemp(r(n),c(n))=(intpldFrameTemp(r(n),c(n))+y_ext(r(n),c(n),2))/2;%取平均
                end
            end
        end
        occ(occ==2)=1;%occ为2元素恢复为1，保证下次加的时候只有1和0
        %PAMC规则进行替换temp中的值
        SADfld(16+1+(i-1)*8+round(mv_fld_y(i,j)/2):16+i*8+round(mv_fld_y(i,j)/2),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)/2):16+j*8+round(mv_fld_x(i,j)/2))=...
            SADfldTemp(16+1+(i-1)*8+round(mv_fld_y(i,j)/2):16+i*8+round(mv_fld_y(i,j)/2),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)/2):16+j*8+round(mv_fld_x(i,j)/2));
        y_ext(16+1+(i-1)*8+round(mv_fld_y(i,j)/2):16+i*8+round(mv_fld_y(i,j)/2),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)/2):16+j*8+round(mv_fld_x(i,j)/2),2)=...
            intpldFrameTemp(16+1+(i-1)*8+round(mv_fld_y(i,j)/2):16+i*8+round(mv_fld_y(i,j)/2),...
            16+1+(j-1)*8+round(mv_fld_x(i,j)/2):16+j*8+round(mv_fld_x(i,j)/2));
        %将temp值装入最终值
    end
end
intpldFrame=y_ext(:,:,2);
intpldFrame=uint8(intpldFrame);
end

